#include <thread>
#include <iostream>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>

class	tileset : public sf::Drawable, public sf::Transformable
{
public :
  tileset() = default;
  ~tileset() = default;
  
  bool	loadTileset(const std::string &&);
  sf::Vertex*	createMap(const sf::Vector2u&, const int, const int);
  sf::Vertex	*quad;
  
private :
  sf::VertexArray m_vertices;
  sf::Texture m_tileset;
  int _x_tileset;
  int _y_tileset;
  sf::Vector2u _tileSize;

  virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const
  {
    // on applique la transformation
    states.transform *= getTransform();

    // on applique la texture du tileset
    states.texture = &m_tileset;

    // et on dessine enfin le tableau de vertex
    target.draw(m_vertices, states);
  }
};


bool tileset::loadTileset(const std::string &&file) {
  if ((m_tileset.loadFromFile(file)) == false)
    return false;
  return true;
}

sf::Vertex*	tileset::createMap(const sf::Vector2u &tileSize, const int x_tileset, const int y_tileset)
{
  this->_tileSize = tileSize;
  this->_x_tileset = x_tileset;
  this->_y_tileset = y_tileset;
  this->m_vertices.setPrimitiveType(sf::Quads);
  this->m_vertices.resize(x_tileset * y_tileset * 4);
  for (unsigned int y = 0; y < y_tileset; ++y) {
    //    std::cout << "y : "  << y << " x :";
    for (unsigned int x = 0; x < x_tileset; ++x) {

      // on en déduit sa position dans la texture du tileset
      int tu = (m_tileset.getSize().x / tileSize.x);
      int tv = (m_tileset.getSize().x / tileSize.x);

      // on récupère un pointeur vers le quad à définir dans le tableau de vertex
      this->quad = &m_vertices[(x + y * y_tileset) * 4]; /* Faire une map correspondant a un INT et à un Vector2u pour le positionnement des textures*/

      // on définit ses quatre coins
      //      quad[0].position = sf::Vector2f(x * tileSize.x, y * tileSize.y);
      //      quad[1].position = sf::Vector2f((x + 1) * tileSize.x, y * tileSize.y);
      //      quad[2].position = sf::Vector2f((x + 1) * tileSize.x, (y + 1) * tileSize.y);
      //      quad[3].position = sf::Vector2f(x * tileSize.x, (y + 1) * tileSize.y);
      quad[0].position = sf::Vector2f(500, 500); /* POSITION SUR LA FENETRE ??*/
      quad[1].position = sf::Vector2f(250, 500);
      quad[2].position = sf::Vector2f(250, 250);
      quad[3].position = sf::Vector2f(500, 250);

      // on définit ses quatre coordonnées de texture
      //      quad[0].texCoords = sf::Vector2f(tu * tileSize.x, tv * tileSize.y);
      //      quad[1].texCoords = sf::Vector2f((tu + 1) * tileSize.x, tv * tileSize.y);
      //      quad[2].texCoords = sf::Vector2f((tu + 1) * tileSize.x, (tv + 1) * tileSize.y);
      //      quad[3].texCoords = sf::Vector2f(tu * tileSize.x, (tv + 1) * tileSize.y);
      quad[0].texCoords = sf::Vector2f(0, 0); /* POSITION SUR LE TILESET ? */
      quad[1].texCoords = sf::Vector2f(80, 0);
      quad[2].texCoords = sf::Vector2f(80, 160);
      quad[3].texCoords = sf::Vector2f(0, 160);
      //      std::cout << x;
    }
    std::cout << std::endl;
  }
  return (this->quad);
}

int	main(void)
{

  tileset	tilesetObj;


  if ((tilesetObj.loadTileset("./texture/rpg.png")) == false) {
    std::cerr << "Error load tileset" << std::endl;
    return (1);
  }
  tilesetObj.createMap(sf::Vector2u(32, 32), 8, 4);
  sf::RenderWindow window(sf::VideoMode(800, 600), "My window");


  // on fait tourner le programme jusqu'à ce que la fenêtre soit fermée

  while (window.isOpen())
    {
      // on inspecte tous les évènements de la fenêtre qui ont été émis depuis la précédente itération
      sf::Event event;
      while (window.pollEvent(event))
	{
	  // évènement "fermeture demandée" : on ferme la fenêtre
	  if (event.type == sf::Event::Closed)
	    window.close();
	}
      window.clear();
      window.draw(tilesetObj);
      window.display();
      std::this_thread::sleep_for (std::chrono::seconds(1));
    }

  return (0);
}
